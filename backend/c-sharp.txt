# C# Backend Development Guide for AI Assistant

## Project Overview
- **Stack**: C#-based backend development (.NET)
- **Purpose**: Standardize AI-assisted code generation for C# backend applications

## Coding Standards

### C# Style
- Follow Microsoft's C# Coding Conventions
- Use 4 spaces for indentation
- Use PascalCase for class, method, property, and public field names
- Use camelCase for local variables and private fields
- Prefix private fields with underscore (_privateField)
- Use UPPER_SNAKE_CASE for constants
- Use var only when the type is obvious from the right side of assignment
- Use predefined type names instead of system type names (string vs String)
- Limit line length to 120 characters
- Include braces even for single-line blocks

### Project Structure
```
YourProject/
├── YourProject.API/              # Web API project
│   ├── Controllers/              # API controllers
│   ├── Middleware/               # Custom middleware
│   ├── Program.cs                # Entry point and configuration
│   └── appsettings.json          # Configuration settings
├── YourProject.Core/             # Business logic project
│   ├── Entities/                 # Domain entities
│   ├── Interfaces/               # Service and repository interfaces
│   ├── DTOs/                     # Data Transfer Objects
│   ├── Exceptions/               # Custom exceptions
│   └── Services/                 # Business logic implementation
├── YourProject.Infrastructure/   # Data access project
│   ├── Data/                     # DbContext and related classes
│   ├── Migrations/               # EF Core migrations
│   ├── Repositories/             # Repository implementations
│   └── External/                 # External service integrations
├── YourProject.Tests/            # Unit and integration tests
│   ├── Controllers/              # Controller tests
│   ├── Services/                 # Service tests
│   └── Repositories/             # Repository tests
└── YourProject.sln               # Solution file
```

### Best Practices
- Follow SOLID principles
- Use dependency injection (built into .NET)
- Make interfaces explicit and focused
- Use async/await for all I/O operations
- Make DTOs immutable where possible
- Use nullable reference types (C# 8+)
- Use expression-bodied members for simple methods
- Use pattern matching where appropriate
- Use string interpolation instead of concatenation
- Use ILogger for structured logging

### .NET Version
- Use .NET 8+ for modern features and long-term support
- Use C# 12+ language features
- Enable nullable reference types
- Enable file-scoped namespaces
- Use global using directives for common imports

### Database Access
- Use Entity Framework Core for ORM
- Implement repository pattern with Unit of Work
- Use migrations for database schema management
- Configure DbContext properly with relationships
- Use LINQ responsibly (avoid N+1 queries)
- Implement proper transaction handling
- Use connection pooling effectively

### API Development
- Follow RESTful API design principles
- Use ASP.NET Core controllers for API endpoints
- Implement proper model validation with Data Annotations or FluentValidation
- Use Action Filters for cross-cutting concerns
- Implement proper response types (ActionResult<T>)
- Use appropriate HTTP status codes
- Version your APIs (URL or header-based)
- Document APIs with Swagger/OpenAPI

### Authentication & Security
- Use ASP.NET Core Identity or IdentityServer
- Implement JWT or OAuth2 authentication
- Use secure password hashing
- Implement proper authorization with policies
- Validate all inputs
- Use HTTPS in all environments
- Protect against common web vulnerabilities
- Follow OWASP security guidelines

### Error Handling
- Use middleware for global exception handling
- Create custom exception types for domain-specific errors
- Return standardized error responses
- Include appropriate error detail based on environment
- Log errors with appropriate severity
- Implement proper validation error handling

### Testing
- Use xUnit, NUnit, or MSTest for unit testing
- Use Moq or NSubstitute for mocking
- Implement integration tests with TestHost
- Use in-memory database for repository tests
- Follow AAA pattern (Arrange, Act, Assert)
- Use FluentAssertions for readable assertions
- Maintain high test coverage

### Configuration & Environment
- Use Options pattern for strongly typed configuration
- Use different appsettings files per environment
- Store secrets in user secrets or Azure Key Vault
- Use IConfiguration for accessing configuration
- Use environment variables for containerized deployments

### Logging & Monitoring
- Use built-in ILogger with Serilog or NLog
- Implement structured logging
- Include correlation IDs for request tracing
- Add health checks endpoints
- Use Application Insights or similar for telemetry

### Build & Deployment
- Use GitHub Actions or Azure DevOps for CI/CD
- Implement Docker containerization
- Create proper Dockerfile with multi-stage builds
- Use environment-specific configuration
- Implement Blue-Green deployment strategy
- Consider serverless options (Azure Functions)